#version 430

layout (local_size_x = 8, local_size_y = 8, local_size_x = 1) in;

layout (r8ui, binding = 0) restrict readonly uniform uimage3D usedClustersPerTile;
layout (r32ui, binding = 1) restrict writeonly uniform uimage1D compactUsedIDs;

layout (std140, binding = 0) buffer atomicBuffer_
{
	uint atomicCounter;
};


const uint clusterPixelSize = 64;
const int numDepthSlices = 16;

void main()
{
    ivec2 fragCoord = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy);

    uvec2 clusterCoord = uvec2(fragCoord.xy);

    uint counter = 0;
    uint values[numDepthSlices];
    for (uint i = 0; i < numDepthSlices; i++) {
        uint clusterUsed = imageLoad(usedClustersPerTile, ivec3(fragCoord, i)).x; // 0 or 1
        if (clusterUsed == 0)
            continue;
        uint clusterID = clusterCoord.x | clusterCoord.y << 8 | i << 16;
        values[counter] = clusterID;
        counter++;
    }

    uint startIndex = atomicAdd(atomicCounter, counter);
    for(int i = 0; i < counter; i++) {
        imageStore(compactUsedIDs, int(startIndex+i), uvec4(values[i], 0, 0, 0));
    }
}
