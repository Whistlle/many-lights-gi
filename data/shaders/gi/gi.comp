#version 430

#extension GL_ARB_shading_language_include : require
#include </data/shaders/ism/ism_utils.glsl>
#include </data/shaders/common/reprojection.glsl>

struct VPL {
    vec3 position;
    vec3 normal;
    vec3 color;
};

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
layout (r11f_g11f_b10f, binding = 0) restrict writeonly uniform image2D img_output;
layout (r16ui, binding = 1) restrict readonly uniform uimage3D lightListIds;
layout (r8ui, binding = 2) restrict readonly uniform uimage2D lightLists;

const int totalVplCount = 1024;
layout (packed, binding = 0) uniform vplBuffer_
{
    VPL vplBuffer[totalVplCount];
};

uniform sampler2D faceNormalSampler;
uniform sampler2D depthSampler;
uniform sampler2D ismDepthSampler;

uniform mat4 projectionMatrix;
uniform mat4 projectionInverseMatrix;
uniform mat4 viewMatrix;
uniform mat4 viewInvertedMatrix;
uniform mat4 viewProjectionInvertedMatrix;
uniform float zFar;
uniform float zNear;
uniform ivec2 viewport;

uniform float giIntensityFactor;
uniform float vplClampingValue;

// don't forget that these uniforms eat performance
uniform int vplStartIndex = 0;
uniform int vplEndIndex = totalVplCount;
int vplCount = vplEndIndex - vplStartIndex;
uniform bool scaleISMs = false;
float ismIndexOffset = scaleISMs ? vplStartIndex : 0;
int ismCount = (scaleISMs) ? vplCount : totalVplCount;
int ismIndices1d = int(pow(2, ceil(log2(ismCount) / 2))); // next even power of two
uniform bool enableShadowing = true;

uniform bool showVPLPositions = false;

uniform bool useInterleaving = true;
uint interleavedSize = useInterleaving ? 4 : 1;
uint interleavedPixels = interleavedSize*interleavedSize;
// number of bits that will be taken from gl_WorkGroupID to determine the interleavedPixel
uint interleaveBits = uint(log2(interleavedSize));
// set interleaveBits rightmost bits to 1
uint interleavedPixelBitmask = (1u << interleaveBits) - 1u;

const uint clusterPixelSize = 128;


const int numDepthSlices = 16;
shared bool[numDepthSlices] usedDepthSlices;
shared int[numDepthSlices] minDepths;
shared int[numDepthSlices] maxDepths;

shared uint[numDepthSlices][64] indices;
shared uint[numDepthSlices] counters;



const int totalSharedVPLS = 64;
shared VPL vpls[totalSharedVPLS]; // interleavedPixels is not constant
shared int sharedVplCounter;

void main()
{
    uint invocationID = gl_LocalInvocationID.x + gl_LocalInvocationID.y * gl_WorkGroupSize.x;

    uvec2 largeInterleaveBlockPosition = (gl_WorkGroupID.xy >> interleaveBits) * gl_WorkGroupSize.xy * interleavedSize;
    uvec2 offsetInLargeInterleaveBlock = gl_LocalInvocationID.xy * interleavedSize;
    uvec2 interleavedPixel = gl_WorkGroupID.xy & interleavedPixelBitmask;
    ivec2 fragCoord = ivec2(largeInterleaveBlockPosition + offsetInLargeInterleaveBlock + interleavedPixel);



    vec2 v_uv = vec2(fragCoord) / viewport;

    // TODO maybe view rays again? could re-use view z for cluster coord
    float depthSample = texelFetch(depthSampler, fragCoord, 0).r;
    vec4 ndc = vec4(v_uv, depthSample, 1.0) * 2.0 - 1.0;
    vec4 fragWorldCoordWithW = viewProjectionInvertedMatrix * ndc;
    vec3 fragWorldCoord = fragWorldCoordWithW.xyz / fragWorldCoordWithW.w;

    vec3 fragNormal = texelFetch(faceNormalSampler, fragCoord, 0).xyz * 2.0 - 1.0;

    const int numDepthSlices = 16;
    const int numSlicesIntoFirstSlice = 3;
    float scaleFactor = (numDepthSlices + numSlicesIntoFirstSlice) / log2(50);
    float depth = linearDepth(depthSample, projectionMatrix);
    int depthSlice = int(max(log2(-depth) * scaleFactor - numSlicesIntoFirstSlice, 0));





    // uvec2 clusterCoord = uvec2(fragCoord.xy) / clusterPixelSize;
    // uint lightListId = imageLoad(lightListIds, ivec3(clusterCoord, clusterZ)).r;
    // uint numVPLs = totalVplCount;

    // numVPLs = totalVplCount;
    uint interleavedPixel1d = interleavedPixel.x + interleavedPixel.y * interleavedSize;

    uint startIndex = totalVplCount / interleavedPixels * interleavedPixel1d;
    // uint numLights = imageLoad(lightLists, ivec2(lightListId, startIndex)).r;

    uint vplIndex = invocationID + startIndex;
    uint shortVplIndex = invocationID;


    // tiled shading begins here
    if (invocationID < 16) {
        minDepths[invocationID] = (10000000);
        maxDepths[invocationID] = (-10000000);
        counters[invocationID] = 0;
    }

    barrier();
    memoryBarrierShared();

    bool inImageBounds = all(lessThan(fragCoord, textureSize(depthSampler, 0).xy));
    if (inImageBounds) {
        usedDepthSlices[depthSlice] = true;

        atomicMin(minDepths[depthSlice], int(ndc.z * 10000));
        atomicMax(maxDepths[depthSlice], int(ndc.z * 10000));
    }

    if (invocationID < 64)
        vpls[invocationID] = vplBuffer[vplIndex];

    barrier();
    memoryBarrierShared();


    if (invocationID < 64) {

        for(int i = 0; i < numDepthSlices; i++) {
            if (!usedDepthSlices[i])
                continue;

            // determine pixel coordinates of bottom left and top right pixels in this tile
            ivec2 bottomLeftFragCoord = ivec2(largeInterleaveBlockPosition + interleavedPixel);
            vec2 bottomLeftNDC = vec2(bottomLeftFragCoord) / viewport * 2.0 - 1.0;

            uvec2 offsetInLargeInterleaveBlock = (gl_WorkGroupSize.xy-1) * interleavedSize;
            uvec2 interleavedPixel = (gl_WorkGroupID.xy-1) & interleavedPixelBitmask;
            ivec2 topRightFragCoord = ivec2(largeInterleaveBlockPosition + offsetInLargeInterleaveBlock + interleavedPixel);
            vec2 topRightNDC = vec2(topRightFragCoord) / viewport * 2.0 - 1.0;


            vec3 minNDCf = vec3(bottomLeftNDC, minDepths[i] / 10000.0f);
            vec3 maxNDCf = vec3(topRightNDC, maxDepths[i] / 10000.0f);

            vec3 corners[8];

            corners[0] = vec3(minNDCf.x, minNDCf.y, minNDCf.z);
            corners[1] = vec3(minNDCf.x, minNDCf.y, maxNDCf.z);
            corners[2] = vec3(maxNDCf.x, minNDCf.y, minNDCf.z);
            corners[3] = vec3(maxNDCf.x, minNDCf.y, maxNDCf.z);
            corners[4] = vec3(minNDCf.x, maxNDCf.y, minNDCf.z);
            corners[5] = vec3(minNDCf.x, maxNDCf.y, maxNDCf.z);
            corners[6] = vec3(maxNDCf.x, maxNDCf.y, minNDCf.z);
            corners[7] = vec3(maxNDCf.x, maxNDCf.y, maxNDCf.z);

            for (int i = 0; i < 8; i++) {
                // vec4 corner =
                vec4 corner = (viewProjectionInvertedMatrix * vec4(corners[i], 1.0));
                corners[i] = corner.xyz / corner.w;
            }


            VPL vpl = vpls[shortVplIndex];
            bool found = false;
            for (int j = 0; j < 8; j++) {
                vec3 corner = corners[j];
                vec3 vplToCorner = corner - vpl.position.xyz;
                vec3 vplNormal = (vpl.normal.xyz);
                found = found || (dot(vplToCorner, vplNormal) >= 0);
            }
            // // found = true;
            // indices[i][shortVplIndex] = int(found);
            if (found) {

                uint index = atomicAdd(counters[i], 1);
                indices[i][index] = shortVplIndex;
            }
        }
    }
    // barrier();
    // memoryBarrierShared();
    //
    // if (invocationID < 16) {
    //     uint counter = 0;
    //     for(int i = 0; i < 64; i++) {
    //         if (!bool(indices[invocationID][i]))
    //             continue;
    //         indices[invocationID][counter] = i;
    //         counter++;
    //     }
    //     counters[invocationID] = counter;
    // }

    barrier();
    memoryBarrierShared();


    vec3 acc = vec3(0.0);
    for (int lightIndex = 0; lightIndex < counters[depthSlice]; lightIndex++) {
        // if (!bool(indices[depthSlice][lightIndex]))
        //     continue;
        uint vplIndex = indices[depthSlice][lightIndex];
        VPL vpl = vpls[vplIndex];

        vec3 diff = fragWorldCoord - vpl.position ;
        float dist = length(diff);
        vec3 normalizedDiff = diff / dist;

        // debug splotch
        float isNearLight = 1.0 - step(0.15, dist);
        vec3 debugSplotch = isNearLight * vpl.color / dist / dist * 0.0001;
        acc += debugSplotch * float(showVPLPositions);

        // geometry term
        float angleFactor = max(0.0, dot(vpl.normal, normalizedDiff)) * max(0.0, dot(fragNormal, -normalizedDiff));
        float attenuation = 1.0 / pow(dist, 4.0);
        float geometryTerm = angleFactor * attenuation;
        geometryTerm = min(geometryTerm, vplClampingValue);

        // ISM shadowing
        float ismIndex = vplIndex + startIndex - ismIndexOffset;
        vec3 v = paraboloid_project(diff, dist, vpl.normal, zFar, ismIndex, ismIndices1d, false);
        float occluderDepth = textureLod(ismDepthSampler, v.xy, 0).x;
        float shadowValue = v.z - occluderDepth;
        float shadowBias = 0.02;
        shadowValue = smoothstep(1.0 - shadowBias, 1.0, 1 - shadowValue);
        shadowValue = mix(1.0, shadowValue, float(enableShadowing));
        // float shadowValue = 1;

        acc += vpl.color * geometryTerm * shadowValue;
    }

    vec3 resultColor = vec3(acc * giIntensityFactor / vplCount) * interleavedPixels;

    // resultColor.rgb = vec3(float((sharedVplCounter) / 64.0f));
    // resultColor.rgb = vec3(ndc.z * 0.5 + 0.5);
    // resultColor.rgb = vec3(vec3(maxNDC[0], maxNDC[1], maxNDC[2]) + 10000000);
    imageStore(img_output, fragCoord, vec4(resultColor, 0.0));
}
