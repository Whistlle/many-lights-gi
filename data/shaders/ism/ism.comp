#version 430

#extension GL_ARB_shading_language_include : require
#include </data/shaders/common/random.glsl>
#include </data/shaders/common/floatpacking.glsl>
#include </data/shaders/ism/ism_utils.glsl>


layout (local_size_x = 64) in;


const int totalVplCount = 1024;
layout (std140, binding = 0) uniform packedVplBuffer_
{
    vec4 vplPositionNormalBuffer[totalVplCount];
};

layout (shared, binding = 0) buffer atomicBuffer_
{
	uint[1024] atomicCounter;
};

layout (r32ui, binding = 0) restrict uniform uimage3D softrenderBuffer;
layout (rgba32f, binding = 1) restrict readonly uniform imageBuffer pointBuffer;

uniform ivec2 viewport;
uniform float zFar;

uniform bool usePushPull = true;

uniform int vplStartIndex = 0;
uniform int vplEndIndex = totalVplCount;
uniform bool scaleISMs = false;
uniform bool pointsOnlyIntoScaledISMs = false;

int vplCount = vplEndIndex - vplStartIndex;
int sampledVplCount = pointsOnlyIntoScaledISMs ? vplCount : totalVplCount;
int ismCount = (scaleISMs) ? vplCount : totalVplCount;
int ismIndices1d = int(ceil(sqrt(ismCount)));
int vplIdOffset = pointsOnlyIntoScaledISMs ? vplStartIndex : 0;

const float infinity = 1. / 0.;

shared vec4[64] vpls;


void main()
{

    uint id = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x;

    // return;

    for (int i = 0; i < 1; i++) {
        uint index = (gl_WorkGroupID.x + gl_LocalInvocationID.x) % 1024u;
        vpls[gl_LocalInvocationID.x] = vplPositionNormalBuffer[index];
    }

        // if (id > atomicCounter[gl_WorkGroupID.x])
        //     return;
    for(int j = 0; j < atomicCounter[gl_WorkGroupID.x] / 64 +1; j++)
    {

    vec4 read = imageLoad(pointBuffer, int(gl_WorkGroupID.x * 4096 + j * 64 + gl_LocalInvocationID.x));

    vec3 position = read.xyz;
    float g_normalRadius = read.w;
    vec4 normalRadiusUnpacked = Unpack4PNFromFP32(g_normalRadius);

    vec3 pointNormal = normalRadiusUnpacked.xyz;
    pointNormal  = pointNormal * 2.0 - 1.0;

    float maxdist = normalRadiusUnpacked.w;


    int vplID;
    vec3 vplNormal;
    vec3 positionRelativeToCamera;
    bool found = false;
    int i;
    // int base = (int(random(position.xyz) * sampledVplCount) + 1);
    // int base = int(id); // TODO
    for(i = 0; i < 8; i++) {
        int vplID2 = (i) % 1024;
        // vplID = int(counter) % 1024;
        // if (pointsOnlyIntoScaledISMs)
        //     vplID2 += vplIdOffset;

        vec4 foo = vpls[vplID2];
        vec3 vplPosition = foo.xyz;
        vec3 vplNormal2 = Unpack3PNFromFP32(foo.w) * 2.0 - 1.0;

        vec3 positionRelativeToCamera2 = position.xyz - vplPosition;

        bool cull = dot(vplNormal2, positionRelativeToCamera2) < 0 || dot(pointNormal, -positionRelativeToCamera2) < 0;
        found = found || !cull;
        if (!cull) {
            vplID = (vplID2 + int(gl_WorkGroupID.x)) % 1024;
            vplNormal = vplNormal2;
            positionRelativeToCamera = positionRelativeToCamera2;
            // break;
        }
    }
    // if (!found)
    //     continue;

    // vec4 foo1 = vplPositionNormalBuffer[vplID];
    // vec4 foo2 = vplPositionNormalBuffer[vplID];
    // vec4 foo3 = vplPositionNormalBuffer[vplID];
    // positionRelativeToCamera += (foo1.xyz + foo2.xyz + foo3.xyz + Unpack3PNFromFP32(foo1.w) + Unpack3PNFromFP32(foo2.w) + Unpack3PNFromFP32(foo3.w)) * 0.00001;
    // positionRelativeToCamera.x += (dot(foo1.xyz, foo2.xyz) + dot(foo3.xyz, Unpack3PNFromFP32(foo3.w) )) * 0.00001;

    // for(i = 0; i < 0; i++) {
    //     int vplID2 = (base + i) % sampledVplCount;
    //     // vplID = int(counter) % 1024;
    //     if (pointsOnlyIntoScaledISMs)
    //         vplID2 += vplIdOffset;
    //
    //     vec4 foo = vplPositionNormalBuffer[vplID2];
    //     vec3 vplPosition = foo.xyz;
    //     vec3 vplNormal2 = Unpack3PNFromFP32(foo.w) * 2.0 - 1.0;
    //
    //     vec3 positionRelativeToCamera2 = position.xyz - vplPosition;
    //
    //     bool cull = dot(vplNormal2, positionRelativeToCamera2) < 0 || dot(pointNormal, -positionRelativeToCamera2) < 0;
    //     // found = found || !cull;
    //     positionRelativeToCamera += min(positionRelativeToCamera2, 1) * 0.0001;
    //     // if (!cull) {
    //     //     vplID = vplID2;
    //     //     vplNormal = vplNormal2;
    //     //     positionRelativeToCamera = positionRelativeToCamera2;
    //     //     // break;
    //     // }
    // }



    // vplNormal = Unpack3PNFromFP32(vplPositionNormalBuffer[vplID].w) * 2.0 - 1.0;
    // vec3 vplPosition = vplPositionNormalBuffer[vplID].xyz;
    // positionRelativeToCamera = position.xyz - vplPosition;

    // paraboloid projection
    float distToCamera = length(positionRelativeToCamera);
    float ismIndex = scaleISMs ? float(vplID) - vplStartIndex : vplID;
    vec3 v = paraboloid_project(positionRelativeToCamera, distToCamera, vplNormal, zFar, ismIndex, ismIndices1d, true);

    vec3 normalPositionRelativeToCamera = positionRelativeToCamera + pointNormal * 0.1;
    float normalDist = length(normalPositionRelativeToCamera);
    vec3 normalV = paraboloid_project(normalPositionRelativeToCamera, normalDist, vplNormal, zFar, ismIndex, ismIndices1d, true);


    // to tex and NDC coords
    v.xy = v.xy * 2.0 - 1.0;
    v.z = v.z * 2.0 - 1.0;

    // gl_Position = vec4(v, 1.0);

    float pointsPerMeter = 1.0 / (maxdist * 2.0);
    float pointSize = 1.0 / pointsPerMeter / distToCamera / 3.14 * viewport.x; // approximation that breaks especially for near points.
    pointSize *= 1.0;
    float maximumPointSize = 15.0;
    pointSize = min(pointSize, maximumPointSize);

    // if (usePushPull) {
        v.xy = v.xy * 0.5 + 0.5;
        v.xy *= 2048;
        v.z  = v.z * 0.5 + 0.5;
        v.z *= 5000;
        uint original = imageAtomicMin(softrenderBuffer, ivec3(v.xy, 0), uint(v.z));
        if (original > uint(v.z)) {
            float radius = pointSize / 2;
            radius *= 1.3; // boost radius a bit to make circle area match the point rendering square area
            uint g_normalRadius = Pack4PNToUint(vec4(pointNormal * 0.5 + 0.5, radius / 15.0));
            // potential race condition here. two threads write into depth, and then both, in a different order, write into attributes.
            // but this should almost never happen in practice, right?
            imageStore(softrenderBuffer, ivec3(v.xy, 1), uvec4(g_normalRadius, 0, 0, 0));
        }
    // }
    // else {
    //     gl_PointSize = pointSize;
    //     // gl_PointSize = 1;
    //     EmitVertex();
    // }
    }
}
