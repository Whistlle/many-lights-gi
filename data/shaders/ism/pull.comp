#version 430

#define READ_FROM_TEXTURE

layout (local_size_x = 8, local_size_y = 8) in;

layout (binding = 0) uniform sampler2D ismDepthTexture;
layout (rgba32f, binding = 0) restrict readonly uniform image2D ismDepthImage;
layout (rgba32f, binding = 1) restrict writeonly uniform image2D img_output;



const float radius = 0.005; // TODO this is totally arbitrary


void main()
{
    ivec2 pixelCoordinate = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy);

    ivec2[4] offsets = { {0,0}, {0,1}, {1,0}, {1,1} };

    float[4] depthSamples;
    float[4] maxDepths;
    vec2[4] displacementVectors;
    bool[4] valid;
    for (int i = 0; i < 4; i++) {
        # ifdef READ_FROM_TEXTURE
            float depthSample = texelFetch(ismDepthTexture, pixelCoordinate * 2 + offsets[i], 0).r;
            // TODO actually read radius from color buffer. small triangles have smaller radiuses than the tesselation results.
            float maxDepth = depthSample + radius;
            vec2 displacementVector = vec2(0.0);
        # else
            vec4 read = imageLoad(ismDepthImage, pixelCoordinate * 2 + offsets[i]);
            float depthSample = read.r;
            float maxDepth = read.g;
            vec2 displacementVector = read.ba;
        # endif

        // radius check
        vec2 pointOrigin = (vec2(pixelCoordinate * 2 + offsets[i]) + displacementVector);

        //TODO read radius from texture
        float pointsPerMeter = 4.0; // actual number unknown, needs to be calculated during tesselation
        float distToCamera = depthSample * 50;
        float pointSize = 1.0 / pointsPerMeter / distToCamera / 3.14 * 2048; // approximation that breaks especially for near points.
        // float maximumPointSize = 20.0;
        // pointSize = min(pointSize, maximumPointSize);

        float radius = pointSize;
        vec2 newDisplacementVector = vec2(pixelCoordinate) * 2 + 0.5 - pointOrigin;
        float dist = length(newDisplacementVector);

        ivec2 coarserLevelSize = imageSize(img_output) * 2;
        ivec2 sizePerISM = coarserLevelSize / 32;
        radius *= float(sizePerISM.x) / 64;

        depthSamples[i] = depthSample;
        maxDepths[i] = maxDepth;
        displacementVectors[i] = displacementVector;
        valid[i] = dist <= radius * 1 && depthSample != 1.0;
    }

    float minimum = 9001;
    float maxDepth;
    for (int i = 0; i < 4; i++) {
        if (!valid[i])
            continue;
        minimum = min(depthSamples[i], minimum);
        if (minimum == depthSamples[i])
            maxDepth = maxDepths[i];
    }

    for(int i = 0; i < 4; i++) {
        if (depthSamples[i] > maxDepth)
            valid[i] = false;
    }

    float depthAcc = 0.0;
    vec2 displacementAcc = vec2(0.0);
    uint numValid = 0;
    float maxValidMaxDepth = 0.0;
    for (int i = 0; i < 4; i++) {
        if (!valid[i])
            continue;

        depthAcc += depthSamples[i];
        displacementAcc += (displacementVectors[i] + (-offsets[i] + 0.5)) / 2;
        maxValidMaxDepth = max(maxValidMaxDepth, maxDepths[i]);
        numValid++;
    }

    vec4 result;
    if (numValid > 0) {
        result.r = depthAcc / numValid;
        result.g = maxValidMaxDepth;
        result.ba = displacementAcc / numValid;
    } else {
        result = vec4(1.0, 0.0, 0.0, 0.0);
    }

    imageStore(img_output, pixelCoordinate, result);
}
