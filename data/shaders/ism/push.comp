#version 430

#define READ_FROM_TEXTURE

layout (local_size_x = 8, local_size_y = 8) in;

layout (binding = 0) uniform sampler2D pullSameLevelTexture;
layout (rgba32f, binding = 0) restrict readonly uniform image2D pullSameLevelImage;
layout (rgba32f, binding = 1) restrict readonly uniform image2D coarserLevel;
layout (rgba32f, binding = 2) restrict writeonly uniform image2D img_output;


vec4 read(ivec2 pixelCoordinate)
{
    # ifdef READ_FROM_TEXTURE
        return texelFetch(pullSameLevelTexture, pixelCoordinate, 0);
    # else
        return imageLoad(pullSameLevelImage, pixelCoordinate);
    # endif
}

void main()
{
    ivec2 pixelCoordinate = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy);

    ivec2 pixelInCoarserPixel = pixelCoordinate % 2;
    ivec2 offset = pixelInCoarserPixel * 2 - 1; // -1 or 1


    ivec2 origTexCoord = pixelCoordinate / 2;
    ivec2 coarserLevelSize = imageSize(coarserLevel);
    ivec2 coarserSizePerISM = coarserLevelSize / 32;


    ivec2[4] offsets = { {0,0}, {0,1}, {1,0}, {1,1} };
    int[4] weights = { 9, 3, 3, 1};
    vec4[4] coarserSamples;
    ivec2[4] texCoords;
    texCoords[0] = pixelCoordinate / 2;
    for (int i = 1 ; i < 4; i++) {
        texCoords[i] = pixelCoordinate / 2 + offset * offsets[i];
        // don't go over ISM borders
        // convert to vec2 to not do integer divisions
        // if (floor(vec2(origTexCoord + coarserSizePerISM) / coarserSizePerISM) != floor(vec2(texCoords[i]+coarserSizePerISM) / coarserSizePerISM)) {
        //     weights[i] = 0;
        //     texCoords[i] = texCoords[0];
        // }
    }


    for (int i = 0 ; i < 4; i++) {
        coarserSamples[i] = imageLoad(coarserLevel, texCoords[i]);
        bool invalid = coarserSamples[i].r == 1.0;
        if (invalid)
            weights[i] = 0;
    }

    bool anyValid = false;
    for (int i = 0 ; i < 4; i++)
        anyValid = anyValid || weights[i] > 0;

    for (int i = 0; i < 4; i++) {
        ivec2 texCoord = pixelCoordinate / 2 + offset * offsets[i];

        // radius check
        vec2 pointOrigin = (offset * offsets[i] + coarserSamples[i].ba);

        //TODO read radius from texture
        float pointsPerMeter = 10.0; // actual number unknown, needs to be calculated during tesselation
        float distToCamera = coarserSamples[i].r * 50;
        float pointSize = 1.0 / pointsPerMeter / distToCamera / 3.14 * 2048; // approximation that breaks especially for near points.
        float maximumPointSize = 8.0;
        pointSize = min(pointSize, maximumPointSize);

        // TODO too complex, might be buggy. maybe do it always in full res coordinates.
        // TODO definitely buggy
        float radius = pointSize;
        coarserSamples[i].ba = (vec2(-offset * 0.5) + offset * offsets[i] * 2 + coarserSamples[i].ba*2);
        float dist = length(coarserSamples[i].ba);

        radius *= float(coarserSizePerISM.x) / 16;
        //TODO get radius to 1
        if (dist > radius * 1)
            weights[i] = 0;
    }

    float depthAcc = 0.0;
    vec2 displacementAcc = vec2(0.0);
    int weightAcc = 0;
    float maxDepthAcc = 0.0;

    for (int i = 0; i < 4; i++) {
        depthAcc += coarserSamples[i].r * weights[i];
        displacementAcc += coarserSamples[i].ba * weights[i];
        maxDepthAcc += coarserSamples[i].g * weights[i];
        weightAcc += weights[i];
    }

    vec4 origSample = read(pixelCoordinate);
    bool invalid = origSample.r == 1.0;

    vec4 result = vec4(0.0);
    if (weightAcc != 0) {
        result.r = depthAcc / weightAcc;
        result.g = maxDepthAcc / weightAcc;
        result.ba = displacementAcc / weightAcc;
    } else {
        result = origSample;
    }

    bool coarserSampleInvalid = coarserSamples[0].r == 1.0;
    coarserSampleInvalid = weights[0] == 0;
    bool occluded = origSample.r > coarserSamples[0].g;
    if (coarserSampleInvalid || !invalid && !occluded) {
        // result = origSample;
        // imageStore(img_output, pixelCoordinate, origSample);
        // return;
    }

    // result = origSample;
    // bool checkerboardWhite = ((pixelCoordinate.x % 2) + (pixelCoordinate.y % 2)) % 2 == 0;
    // result.r = float(checkerboardWhite);
    imageStore(img_output, pixelCoordinate, result);
}
